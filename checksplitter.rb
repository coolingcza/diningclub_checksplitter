require "pry"

# Class: Person
#
# Models a person with relevant attributes.
#
# Attributes:
# @name         - String: person's name.
# @spending_amt - Number: zero at initialization.
# @destinations - Array: emtpy at initialization.
#
# Public Methods:
# #spend
# #places

class Person
  attr_reader :name, :spending_amt, :destinations
  
  def initialize(name)
    @name = name
    @spending_amt = 0
    @destinations = []
  end
  
  # Public: #spend
  # Adds amt parameter to @spending_amt.
  #
  # Parameters:
  # amt - Number: person's bill from Dining Club Event.
  #
  # Returns:
  # Updated @spending_amt.
  #
  # State Changes:
  # Increases @spending_amt.
  
  def spend(amt)
    @spending_amt += amt
  end
  
  # Public: #places
  # Adds location to @destinations array.
  #
  # Parameters:
  # dest - String: location of Dining Club Event.
  #
  # Returns:
  # Updated @destinations.
  #
  # State Changes:
  # Updates @destinations.
  
  def places(dest)
    @destinations << dest
  end
  
end
  
  

# Class: DinnerClub
#
# Models a dinner club that includes a number of diners.
#
# Attributes:
# @members     - Array: contains string values for each member's name.
# @member_list - Hash: contains running check totals for diners.
#
# Public Methods:
# #add_member
# #rem_member
# #event_go
# #check_members
# #upd_running_totals
# #upd_member_destinations

class DinnerClub
  attr_reader :member_list
  
  # Public: #initialize
  # Creates DinnerClub object and populates @member_list with initial values.
  #
  # Parameters:
  # members - Array: contains member names.
  #
  # Returns:
  # None.
  #
  # State Changes:
  # Creates @member_list hash from @members.
  
  def initialize(*members)
    @members = members
    @member_list = {}
    @members.each { |m| @member_list[m] = Person.new(m) }
  end
  
  # Public: #add_member
  # Adds member to @member_list.
  #
  # Parameters:
  # new_member - String: new member's name.
  #
  # Returns:
  # Updated @member_list.
  #
  # State Changes:
  # @member_list updated with new member key = new Person object.
  
  def add_member(new_member)
    @member_list[new_member] = Person.new(new_member)
  end
  
  # Public: #rem_member
  # Removes member from @member_list.
  #
  # Parameters:
  # member - String: name of member to be removed.
  #
  # Returns:
  # Updated @member_list.
  #
  # State Changes:
  # Item in @member_list is removed.
  
  def rem_member(member)
    @member_list.delete(member)
  end
  
  # Public: #event_go
  # Generates CheckSplitter object, calls #check_members, #upd_running_totals,
  # #upd_member_destinations to update Person attributes for attendees.
  #
  # Parameters:
  # eventobj - Event: object generated by Event class.
  #
  # Returns:
  # Updated Person objects in @member_list.
  #
  # State Changes:
  # Person object attributes of attendees in @member_list.
  
  def event_go(eventobj)
    event_check = CheckSplitter.new(eventobj.bill, eventobj.attendees.length)
    check_members(eventobj)
    upd_running_totals(eventobj,event_check)
    upd_member_destinations(eventobj)
    @member_list
  end
  
  # Public: #check_members
  # Adds new member if Event attendees list contains name not included in @member_list.
  #
  # Parameters:
  # eventobj - Event object: passed in from #event_go.
  #
  # Returns:
  # @member_list updated with new Person object.
  #
  # State Changes:
  # @member_list if new member.
  
  def check_members(eventobj)
    eventobj.attendees.each do |a| 
      unless @member_list.include?(a)
        add_member(a)
      end
    end
    @member_list
  end
  
  # Public: #upd_running_totals
  # Calls Person.spend to increase Person.spending_amt by tab at Dining Club Event.
  #
  # Parameters:
  # eventobj_name - Event object: passed in from #event_go.
  # event_check   - CheckSplitter object: generated in #event_go
  #
  # Returns:
  # Updated Person objects in @member_list.
  #
  # State Changes:
  # Person.spending_amt numbers of Event attendees.
  
  def upd_running_totals(eventobj_name, event_check)
    if eventobj_name.treat
      @member_list[eventobj_name.treater].spend(event_check.total_bill)
    else
      eventobj_name.attendees.each { |a| @member_list[a].spend(event_check.per_person) }
    end
  end
  
  # Public: #upd_member_destinations
  # Calls Person.places to record locations of events attended.
  #
  # Parameters:
  # eventobj - Event: a Dining Club Event object.
  #
  # Returns:
  # Updated member objects in @member_list.
  #
  # State Changes:
  # Member object destination arrays.
  
  def upd_member_destinations(eventobj)
    eventobj.attendees.each { |a| @member_list[a].places(eventobj.destination) }
  end
  
end
    

# Class: Event
#
# Models an event attended by a Dinner Club.
#
# Attributes:
# @attendees    - Array: Members of dinner club attending event.
# @destination  - String: restaurant name where event is hosted.
# @bill         - Float: Bill for event for entire group.
# @treat        - Boolean: True if one member of the dinner club pays entire bill.
# @treater      - String: acquired if @treat, name of member who pays entire bill.
#
# Public Methods:
# none

class Event
  attr_reader :attendees
  attr_reader :destination
  attr_reader :bill
  attr_reader :treat
  attr_reader :treater
  
  # Public: #initialize
  # Creates Event object and acquires @treater if @treat is true.
  #
  # Parameters:
  # attendees   - Array: contains names of Dinner Club members who attend event.
  # destination - String: name of restaurant at which event is held.
  # bill        - Float: bill for entire party.
  # treat       - Boolean: default false, true if one member is paying for entire party.
  #
  # Returns:
  # None.
  #
  # State Changes:
  # Creates and fills @treater if @treat is true.
  
  def initialize(attendees, destination, bill, treat=false)
    @attendees = attendees
    @destination = destination
    @bill = bill
    @treat = treat
    if @treat
      puts "Who is treating?"
      @treater = gets.chomp
    end
  end

end

# Class: CheckSplitter
#
# Given a single bill, calculates restaurant tab for member of large party including tip.
#
# Attributes:
# @bill       - Float: bill for entire group.
# @tip        - Integer: percent tip to leave. Default: 15.
# @party_size - Integer: number of people in the party.
#
# Public Methods:
# #total_bill
# #per_person

class CheckSplitter
  
  attr_reader :tip
  attr_reader :bill
  attr_reader :party_size
  
  def initialize(bill, tip=15, party_size)
    @bill = bill
    @tip = tip/100.0
    @party_size = party_size
  end
  
  # Public: #total_bill
  # Calculates the bill plus tip.
  #
  # Parameters:
  # bill - bill for entire group.
  # tip  - decimal tip number.
  #
  # Returns:
  # total_bill: bill including tip.
  #
  # State Changes:
  # None.
  
  def total_bill
    (@bill * (1 + @tip)).ceil.to_i
  end
  
  # Public: #per_person
  # Returns amount of tab for each member of dining party.
  #
  # Parameters:
  # total_bill - Return from total_bill method.
  # party_size - Integer: size of dining party.
  #
  # Returns:
  # Per_person: tab per party member.
  #
  # State Changes:
  # None.
  
  def per_person
    (total_bill / @party_size).ceil.to_i
  end
  
end

#group = DinnerClub.new("Sally","Mark","John","Claire","Jim","Sunny")

#party = Event.new(["Sally","Mark","John","Claire","Jim","Sunny"], "Granite City", 120.45)
#lunch = Event.new(["Mark","Claire","Sunny","Bob"], "Chili's", 36.8, true)
#holiday = Event.new(["Sally","Mark","John","Jim","Sunny"], "Silverthorn", 346.4)


#binding.pry